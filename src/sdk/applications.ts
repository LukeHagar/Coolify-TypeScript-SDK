/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { applicationsCreateDockerCompose } from "../funcs/applicationsCreateDockerCompose.js";
import { applicationsCreateDockerfile } from "../funcs/applicationsCreateDockerfile.js";
import { applicationsCreateDockerImage } from "../funcs/applicationsCreateDockerImage.js";
import { applicationsCreateEnv } from "../funcs/applicationsCreateEnv.js";
import { applicationsCreatePrivateDeployKey } from "../funcs/applicationsCreatePrivateDeployKey.js";
import { applicationsCreatePrivateGithubApp } from "../funcs/applicationsCreatePrivateGithubApp.js";
import { applicationsCreatePublic } from "../funcs/applicationsCreatePublic.js";
import { applicationsDelete } from "../funcs/applicationsDelete.js";
import { applicationsDeleteEnv } from "../funcs/applicationsDeleteEnv.js";
import { applicationsExecuteCommand } from "../funcs/applicationsExecuteCommand.js";
import { applicationsGet } from "../funcs/applicationsGet.js";
import { applicationsList } from "../funcs/applicationsList.js";
import { applicationsListEnvs } from "../funcs/applicationsListEnvs.js";
import { applicationsRestart } from "../funcs/applicationsRestart.js";
import { applicationsStart } from "../funcs/applicationsStart.js";
import { applicationsStop } from "../funcs/applicationsStop.js";
import { applicationsUpdate } from "../funcs/applicationsUpdate.js";
import { applicationsUpdateEnv } from "../funcs/applicationsUpdateEnv.js";
import { applicationsUpdateEnvsBulk } from "../funcs/applicationsUpdateEnvsBulk.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Applications extends ClientSDK {
  /**
   * List
   *
   * @remarks
   * List all applications.
   */
  async list(
    options?: RequestOptions,
  ): Promise<Array<components.Application>> {
    return unwrapAsync(applicationsList(
      this,
      options,
    ));
  }

  /**
   * Create (Public)
   *
   * @remarks
   * Create new application based on a public git repository.
   */
  async createPublic(
    request: operations.CreatePublicApplicationRequestBody,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(applicationsCreatePublic(
      this,
      request,
      options,
    ));
  }

  /**
   * Create (Private - GH App)
   *
   * @remarks
   * Create new application based on a private repository through a Github App.
   */
  async createPrivateGithubApp(
    request: operations.CreatePrivateGithubAppApplicationRequestBody,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(applicationsCreatePrivateGithubApp(
      this,
      request,
      options,
    ));
  }

  /**
   * Create (Private - Deploy Key)
   *
   * @remarks
   * Create new application based on a private repository through a Deploy Key.
   */
  async createPrivateDeployKey(
    request: operations.CreatePrivateDeployKeyApplicationRequestBody,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(applicationsCreatePrivateDeployKey(
      this,
      request,
      options,
    ));
  }

  /**
   * Create (Dockerfile)
   *
   * @remarks
   * Create new application based on a simple Dockerfile.
   */
  async createDockerfile(
    request: operations.CreateDockerfileApplicationRequestBody,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(applicationsCreateDockerfile(
      this,
      request,
      options,
    ));
  }

  /**
   * Create (Docker Image)
   *
   * @remarks
   * Create new application based on a prebuilt docker image
   */
  async createDockerImage(
    request: operations.CreateDockerimageApplicationRequestBody,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(applicationsCreateDockerImage(
      this,
      request,
      options,
    ));
  }

  /**
   * Create (Docker Compose)
   *
   * @remarks
   * Create new application based on a docker-compose file.
   */
  async createDockerCompose(
    request: operations.CreateDockercomposeApplicationRequestBody,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(applicationsCreateDockerCompose(
      this,
      request,
      options,
    ));
  }

  /**
   * Get
   *
   * @remarks
   * Get application by UUID.
   */
  async get(
    request: operations.GetApplicationByUuidRequest,
    options?: RequestOptions,
  ): Promise<components.Application> {
    return unwrapAsync(applicationsGet(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete
   *
   * @remarks
   * Delete application by UUID.
   */
  async delete(
    request: operations.DeleteApplicationByUuidRequest,
    options?: RequestOptions,
  ): Promise<operations.DeleteApplicationByUuidResponseBody> {
    return unwrapAsync(applicationsDelete(
      this,
      request,
      options,
    ));
  }

  /**
   * Update
   *
   * @remarks
   * Update application by UUID.
   */
  async update(
    request: operations.UpdateApplicationByUuidRequest,
    options?: RequestOptions,
  ): Promise<operations.UpdateApplicationByUuidResponseBody> {
    return unwrapAsync(applicationsUpdate(
      this,
      request,
      options,
    ));
  }

  /**
   * List Envs
   *
   * @remarks
   * List all envs by application UUID.
   */
  async listEnvs(
    request: operations.ListEnvsByApplicationUuidRequest,
    options?: RequestOptions,
  ): Promise<Array<components.EnvironmentVariable>> {
    return unwrapAsync(applicationsListEnvs(
      this,
      request,
      options,
    ));
  }

  /**
   * Create Env
   *
   * @remarks
   * Create env by application UUID.
   */
  async createEnv(
    request: operations.CreateEnvByApplicationUuidRequest,
    options?: RequestOptions,
  ): Promise<operations.CreateEnvByApplicationUuidResponseBody> {
    return unwrapAsync(applicationsCreateEnv(
      this,
      request,
      options,
    ));
  }

  /**
   * Update Env
   *
   * @remarks
   * Update env by application UUID.
   */
  async updateEnv(
    request: operations.UpdateEnvByApplicationUuidRequest,
    options?: RequestOptions,
  ): Promise<operations.UpdateEnvByApplicationUuidResponseBody> {
    return unwrapAsync(applicationsUpdateEnv(
      this,
      request,
      options,
    ));
  }

  /**
   * Update Envs (Bulk)
   *
   * @remarks
   * Update multiple envs by application UUID.
   */
  async updateEnvsBulk(
    request: operations.UpdateEnvsByApplicationUuidRequest,
    options?: RequestOptions,
  ): Promise<operations.UpdateEnvsByApplicationUuidResponseBody> {
    return unwrapAsync(applicationsUpdateEnvsBulk(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete Env
   *
   * @remarks
   * Delete env by UUID.
   */
  async deleteEnv(
    request: operations.DeleteEnvByApplicationUuidRequest,
    options?: RequestOptions,
  ): Promise<operations.DeleteEnvByApplicationUuidResponseBody> {
    return unwrapAsync(applicationsDeleteEnv(
      this,
      request,
      options,
    ));
  }

  /**
   * Start
   *
   * @remarks
   * Start application. `Post` request is also accepted.
   */
  async start(
    request: operations.StartApplicationByUuidRequest,
    options?: RequestOptions,
  ): Promise<operations.StartApplicationByUuidResponseBody> {
    return unwrapAsync(applicationsStart(
      this,
      request,
      options,
    ));
  }

  /**
   * Stop
   *
   * @remarks
   * Stop application. `Post` request is also accepted.
   */
  async stop(
    request: operations.StopApplicationByUuidRequest,
    options?: RequestOptions,
  ): Promise<operations.StopApplicationByUuidResponseBody> {
    return unwrapAsync(applicationsStop(
      this,
      request,
      options,
    ));
  }

  /**
   * Restart
   *
   * @remarks
   * Restart application. `Post` request is also accepted.
   */
  async restart(
    request: operations.RestartApplicationByUuidRequest,
    options?: RequestOptions,
  ): Promise<operations.RestartApplicationByUuidResponseBody> {
    return unwrapAsync(applicationsRestart(
      this,
      request,
      options,
    ));
  }

  /**
   * Execute Command
   *
   * @remarks
   * Execute a command on the application's current container.
   */
  async executeCommand(
    request: operations.ExecuteCommandApplicationRequest,
    options?: RequestOptions,
  ): Promise<operations.ExecuteCommandApplicationResponseBody> {
    return unwrapAsync(applicationsExecuteCommand(
      this,
      request,
      options,
    ));
  }
}
