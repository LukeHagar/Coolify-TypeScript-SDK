/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The proxy configuration.
 */
export type Proxy = {};

/**
 * The proxy type.
 */
export const ProxyType = {
  Traefik: "traefik",
  Caddy: "caddy",
  None: "none",
} as const;
/**
 * The proxy type.
 */
export type ProxyType = ClosedEnum<typeof ProxyType>;

/**
 * Server model
 */
export type Server = {
  /**
   * The server ID.
   */
  id?: number | undefined;
  /**
   * The server UUID.
   */
  uuid?: string | undefined;
  /**
   * The server name.
   */
  name?: string | undefined;
  /**
   * The server description.
   */
  description?: string | undefined;
  /**
   * The IP address.
   */
  ip?: string | undefined;
  /**
   * The user.
   */
  user?: string | undefined;
  /**
   * The port number.
   */
  port?: number | undefined;
  /**
   * The proxy configuration.
   */
  proxy?: Proxy | undefined;
  /**
   * The proxy type.
   */
  proxyType?: ProxyType | undefined;
  /**
   * The flag to indicate if the high disk usage notification has been sent.
   */
  highDiskUsageNotificationSent?: boolean | undefined;
  /**
   * The flag to indicate if the unreachable notification has been sent.
   */
  unreachableNotificationSent?: boolean | undefined;
  /**
   * The unreachable count for your server.
   */
  unreachableCount?: number | undefined;
  /**
   * The validation logs.
   */
  validationLogs?: string | undefined;
  /**
   * The flag to indicate if the log drain notification has been sent.
   */
  logDrainNotificationSent?: boolean | undefined;
  /**
   * The swarm cluster configuration.
   */
  swarmCluster?: string | undefined;
  /**
   * The flag to indicate if the unused volumes should be deleted.
   */
  deleteUnusedVolumes?: boolean | undefined;
  /**
   * The flag to indicate if the unused networks should be deleted.
   */
  deleteUnusedNetworks?: boolean | undefined;
};

/** @internal */
export const Proxy$inboundSchema: z.ZodType<Proxy, z.ZodTypeDef, unknown> = z
  .object({});

/** @internal */
export type Proxy$Outbound = {};

/** @internal */
export const Proxy$outboundSchema: z.ZodType<
  Proxy$Outbound,
  z.ZodTypeDef,
  Proxy
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Proxy$ {
  /** @deprecated use `Proxy$inboundSchema` instead. */
  export const inboundSchema = Proxy$inboundSchema;
  /** @deprecated use `Proxy$outboundSchema` instead. */
  export const outboundSchema = Proxy$outboundSchema;
  /** @deprecated use `Proxy$Outbound` instead. */
  export type Outbound = Proxy$Outbound;
}

export function proxyToJSON(proxy: Proxy): string {
  return JSON.stringify(Proxy$outboundSchema.parse(proxy));
}

export function proxyFromJSON(
  jsonString: string,
): SafeParseResult<Proxy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Proxy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Proxy' from JSON`,
  );
}

/** @internal */
export const ProxyType$inboundSchema: z.ZodNativeEnum<typeof ProxyType> = z
  .nativeEnum(ProxyType);

/** @internal */
export const ProxyType$outboundSchema: z.ZodNativeEnum<typeof ProxyType> =
  ProxyType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ProxyType$ {
  /** @deprecated use `ProxyType$inboundSchema` instead. */
  export const inboundSchema = ProxyType$inboundSchema;
  /** @deprecated use `ProxyType$outboundSchema` instead. */
  export const outboundSchema = ProxyType$outboundSchema;
}

/** @internal */
export const Server$inboundSchema: z.ZodType<Server, z.ZodTypeDef, unknown> = z
  .object({
    id: z.number().int().optional(),
    uuid: z.string().optional(),
    name: z.string().optional(),
    description: z.string().optional(),
    ip: z.string().optional(),
    user: z.string().optional(),
    port: z.number().int().optional(),
    proxy: z.lazy(() => Proxy$inboundSchema).optional(),
    proxy_type: ProxyType$inboundSchema.optional(),
    high_disk_usage_notification_sent: z.boolean().optional(),
    unreachable_notification_sent: z.boolean().optional(),
    unreachable_count: z.number().int().optional(),
    validation_logs: z.string().optional(),
    log_drain_notification_sent: z.boolean().optional(),
    swarm_cluster: z.string().optional(),
    delete_unused_volumes: z.boolean().optional(),
    delete_unused_networks: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "proxy_type": "proxyType",
      "high_disk_usage_notification_sent": "highDiskUsageNotificationSent",
      "unreachable_notification_sent": "unreachableNotificationSent",
      "unreachable_count": "unreachableCount",
      "validation_logs": "validationLogs",
      "log_drain_notification_sent": "logDrainNotificationSent",
      "swarm_cluster": "swarmCluster",
      "delete_unused_volumes": "deleteUnusedVolumes",
      "delete_unused_networks": "deleteUnusedNetworks",
    });
  });

/** @internal */
export type Server$Outbound = {
  id?: number | undefined;
  uuid?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  ip?: string | undefined;
  user?: string | undefined;
  port?: number | undefined;
  proxy?: Proxy$Outbound | undefined;
  proxy_type?: string | undefined;
  high_disk_usage_notification_sent?: boolean | undefined;
  unreachable_notification_sent?: boolean | undefined;
  unreachable_count?: number | undefined;
  validation_logs?: string | undefined;
  log_drain_notification_sent?: boolean | undefined;
  swarm_cluster?: string | undefined;
  delete_unused_volumes?: boolean | undefined;
  delete_unused_networks?: boolean | undefined;
};

/** @internal */
export const Server$outboundSchema: z.ZodType<
  Server$Outbound,
  z.ZodTypeDef,
  Server
> = z.object({
  id: z.number().int().optional(),
  uuid: z.string().optional(),
  name: z.string().optional(),
  description: z.string().optional(),
  ip: z.string().optional(),
  user: z.string().optional(),
  port: z.number().int().optional(),
  proxy: z.lazy(() => Proxy$outboundSchema).optional(),
  proxyType: ProxyType$outboundSchema.optional(),
  highDiskUsageNotificationSent: z.boolean().optional(),
  unreachableNotificationSent: z.boolean().optional(),
  unreachableCount: z.number().int().optional(),
  validationLogs: z.string().optional(),
  logDrainNotificationSent: z.boolean().optional(),
  swarmCluster: z.string().optional(),
  deleteUnusedVolumes: z.boolean().optional(),
  deleteUnusedNetworks: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    proxyType: "proxy_type",
    highDiskUsageNotificationSent: "high_disk_usage_notification_sent",
    unreachableNotificationSent: "unreachable_notification_sent",
    unreachableCount: "unreachable_count",
    validationLogs: "validation_logs",
    logDrainNotificationSent: "log_drain_notification_sent",
    swarmCluster: "swarm_cluster",
    deleteUnusedVolumes: "delete_unused_volumes",
    deleteUnusedNetworks: "delete_unused_networks",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Server$ {
  /** @deprecated use `Server$inboundSchema` instead. */
  export const inboundSchema = Server$inboundSchema;
  /** @deprecated use `Server$outboundSchema` instead. */
  export const outboundSchema = Server$outboundSchema;
  /** @deprecated use `Server$Outbound` instead. */
  export type Outbound = Server$Outbound;
}

export function serverToJSON(server: Server): string {
  return JSON.stringify(Server$outboundSchema.parse(server));
}

export function serverFromJSON(
  jsonString: string,
): SafeParseResult<Server, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Server$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Server' from JSON`,
  );
}
